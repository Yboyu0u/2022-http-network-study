## 콘텐츠 인코딩(Contents-Encoding)
- 큰 HTML 문서 전송의 시간을 줄이기 위해 사용 
- 혹은 허락받지 않은 제3자가 볼 수 없게 콘텐츠를 암호화하거나 뒤섞어서 보내는 목적 
- gzip, compress, deflate, identity와 같은 알고리즘을 사용 


### 과정 
- 웹 서버가 Content-Type, Content-Length 헤더를 가진 원본 응답 메시지 생성 
- 콘텐츠 인코딩 서버 (오리진 서버 혹은 다운스트림 프록시)가 인코딩된 메시지 생성
    - 이때 인코딩된 메시지는 Content-Type은 같지만 Content-Length는 다름 
    - 인코딩 서버는 Content-Encoding 헤더를 인코딩된 메시지에 추가하여 수신 측 앱이 디코딩하도록 함 
- 수신 프로그램은 인코딩된 메시지를 받아 디코딩 후 원본 획득     

##  청크 인코딩(Chunked Encoding)
- 메시지를 일정 크기의 여러개의 청크로 쪼개고, 서버는 각 청크를 순서대로 보낸다. 
- 본문이 동적으로 생성되면서 서버는 그중 일부를 버퍼에 담은 뒤 그 한 청크를 그것의 크기와 함꼐 보낼 수 있다.
    - 서버는 본문 전체를 모두 보낼 때까지 이 단계를 반복한다. 
- "Content-Length"는 body 사이즈를 정하는 Header임. Context-Length 대신 "Transfer-Encoding : chunked'가 온다면 chunk단위로 데이터를 전송 하겠다는 뜻    
- 동적으로 생성되는 자원에 대한 전송에 유리 (스트림 등)
- 응답에 대한 데이터 크기를 알 필요가 없음

### 청크 인코딩된 메시지의 구조
![img.png](img.png)
- 각 청크는 길이 값과 각 청크에 대한 데이터를 담고 있다. 길이 값은 16진수 형식으로 되어 있다.
- 데이터는 청크 데이터와 CRLF로 분리된다. 
- 청크 데이터의 길이는 바이트 단위로 측정되고 청크 끝의 CRLF 문자열뿐 아니라 길이 값과 데이터 사이의 CRLF 뭊나열도 길이에 포함하지 않는다. 
- 마지막 청크는 특별히 본문의 끝을 의미하기 위해 길이가 0이다. 

### 청크와 지속 커넥션 
- 지속 커넥션에서는, 본문을 쓰기 전에 반드시 Content-Length 헤더에 본문의 길이를 담아 보내야 한다.
- 콘테츠가 서버에서 동적으로 생성되는 경우에는, 보내기 전에 본문의 길이를 알아내는 것이 불가능하다.
- 청크 인코딩은 서버가 본문을 여러 청크로 쪼개 보낼 수 있게 해줌으로써 이 딜레마에 대한 해법을 제공해 준다. 
- 서버는 크기가 0인 청크로 본문이 끝났음을 알리고 다음 응답을 위해 커넥션을 열린 채로 유지할 수 있다. 